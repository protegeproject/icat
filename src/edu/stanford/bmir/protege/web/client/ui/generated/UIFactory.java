package edu.stanford.bmir.protege.web.client.ui.generated;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import edu.stanford.bmir.protege.web.client.ui.ontology.SWRL.SWRLTab;
import edu.stanford.bmir.protege.web.client.ui.ontology.SWRL.SWRLTabPortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.classes.AllPropertiesPortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.classes.ClassTreePortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.classes.ClassesTab;
import edu.stanford.bmir.protege.web.client.ui.ontology.home.OntologiesPortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.individuals.IndividualsListPortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.individuals.IndividualsTab;
import edu.stanford.bmir.protege.web.client.ui.ontology.metadata.AnnotationsPortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.metadata.ImportsTreePortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.metadata.MetadataTab;
import edu.stanford.bmir.protege.web.client.ui.ontology.metadata.MetricsPortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.notes.NotesPortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.notes.NotesTab;
import edu.stanford.bmir.protege.web.client.ui.ontology.properties.PropertiesTab;
import edu.stanford.bmir.protege.web.client.ui.ontology.properties.PropertiesTreePortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.restrictions.RestrictionsPortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.search.BioPortalSearchPortlet;
import edu.stanford.bmir.protege.web.client.ui.ontology.search.OtherTerminologiesTab;
import edu.stanford.bmir.protege.web.client.ui.portlet.EntityPortlet;
import edu.stanford.bmir.protege.web.client.ui.portlet.propertyForm.PropertyFieldPortlet;
import edu.stanford.bmir.protege.web.client.ui.tab.AbstractTab;
import edu.stanford.bmir.protege.web.client.ui.tab.UserDefinedTab;
import edu.stanford.bmir.protege.web.client.util.Project;

/**
 * This class is supposed to be automatically generated by the GWT generator at
 * compile time. In the current version it is not.
 * 
 * This is a factory class that will provide create methods for all tabs and
 * portlets. The UI configurator will use this class to layout the UI for a
 * particular project and user.
 * 
 * This factory tries to compensate for the lack of reflection support in GWT
 * and JS.
 * 
 * @author Tania Tudorache <tudorache@stanford.edu>
 * 
 */
public class UIFactory {

	// restrict instantiation, since all methods in this class are static
	private UIFactory() {
	}

	/*
	 * Tab factory
	 */

	public static AbstractTab createTab(Project project, String tabJavaClassName) {
		if (tabJavaClassName.equals(ClassesTab.class.getName())) {
			return new ClassesTab(project);
		} else if (tabJavaClassName.equals(PropertiesTab.class.getName())) {
			return new PropertiesTab(project);
		} else if (tabJavaClassName.equals(IndividualsTab.class.getName())) {
			return new IndividualsTab(project);
		} else if (tabJavaClassName.equals(MetadataTab.class.getName())) {
			return new MetadataTab(project);
		} else if (tabJavaClassName.equals(NotesTab.class.getName())) {
			return new NotesTab(project);
		} else if (tabJavaClassName.equals(OtherTerminologiesTab.class.getName())) {
			return new OtherTerminologiesTab(project);
		} else if (tabJavaClassName.equals(UserDefinedTab.class.getName())) {
			return new UserDefinedTab(project);
		} else if (tabJavaClassName.equals(SWRLTab.class.getName())) {
			return new SWRLTab(project);
		}
		return null;
	}

	/*
	 * Portlet factory
	 */

	public static EntityPortlet createPortlet(Project project,
	    String portletJavaClassName) {
		if (portletJavaClassName.equals(AllPropertiesPortlet.class.getName())) {
			return new AllPropertiesPortlet(project);
		} else if (portletJavaClassName.equals(AnnotationsPortlet.class.getName())) {
			return new AnnotationsPortlet(project);
		} else if (portletJavaClassName.equals(ClassTreePortlet.class.getName())) {
			return new ClassTreePortlet(project);
		} else if (portletJavaClassName.equals(ImportsTreePortlet.class.getName())) {
			return new ImportsTreePortlet(project);
		} else if (portletJavaClassName.equals(IndividualsListPortlet.class.getName())) {
			return new IndividualsListPortlet(project);
		} else if (portletJavaClassName.equals(MetricsPortlet.class.getName())) {
			return new MetricsPortlet(project);
		} else if (portletJavaClassName.equals(NotesPortlet.class.getName())) {
			return new NotesPortlet(project);
		} else if (portletJavaClassName.equals(OntologiesPortlet.class.getName())) {
			return new OntologiesPortlet(project);
		} else if (portletJavaClassName.equals(PropertiesTreePortlet.class.getName())) {
			return new PropertiesTreePortlet(project);
		} else if (portletJavaClassName.equals(RestrictionsPortlet.class.getName())) {
			return new RestrictionsPortlet(project);
		} else if (portletJavaClassName.equals(PropertyFieldPortlet.class.getName())) {
			return new PropertyFieldPortlet(project);
		} else if (portletJavaClassName.equals(BioPortalSearchPortlet.class.getName())) {
			return new BioPortalSearchPortlet(project);
		} else if (portletJavaClassName.equals(SWRLTabPortlet.class.getName())) {
			return new SWRLTabPortlet(project);
		}
		return null;
	}

	public static List<String> getAvailableTabNames() {
		String[] tabs =
		        { ClassesTab.class.getName(), PropertiesTab.class.getName(),
		                IndividualsTab.class.getName(),
		                MetadataTab.class.getName(), NotesTab.class.getName(),
		                OtherTerminologiesTab.class.getName(),
		                SWRLTab.class.getName() };
		return Arrays.asList(tabs);
	}

	public static List<String> getAvailablePortletNames() {
		String[] portlets =
		        { AllPropertiesPortlet.class.getName(),
		                ClassTreePortlet.class.getName(),
		                ImportsTreePortlet.class.getName(),
		                IndividualsListPortlet.class.getName(),
		                MetricsPortlet.class.getName(),
		                NotesPortlet.class.getName(),
		                OntologiesPortlet.class.getName(),
		                PropertiesTreePortlet.class.getName(),
		                RestrictionsPortlet.class.getName(),
		                PropertyFieldPortlet.class.getName(),
		                BioPortalSearchPortlet.class.getName() };
		return Arrays.asList(portlets);
	}

	/*
	 * Generic utils
	 */

	public static List<String> getAvailableTabShortNames() {
		List<String> tabs = getAvailableTabNames();
		List<String> shortNames = new ArrayList<String>();
		for (String tab : tabs) {
			shortNames.add(tab.substring(tab.lastIndexOf(".") + 1));
		}
		return shortNames;
	}

	/**
	 * @return A map from the short names of the portlets to the full java class
	 *         name of the portlets.
	 */
	public static Map<String, String> getAvailablePortletNameMap() {
		List<String> portlets = getAvailablePortletNames();
		Collections.sort(portlets);
		Map<String, String> map = new LinkedHashMap<String, String>();
		for (String portlet : portlets) {
			map.put(portlet.substring(portlet.lastIndexOf(".") + 1), portlet);
		}
		return map;
	}

	/**
	 * @return A map from the short names of tabs (label) to the full java class
	 *         name of the tabs.
	 */
	public static Map<String, String> getAvailableTabNameMap() {
		List<String> tabs = getAvailableTabNames();
		Collections.sort(tabs);
		Map<String, String> map = new LinkedHashMap<String, String>();
		for (String tab : tabs) {
			map.put(tab.substring(tab.lastIndexOf(".") + 1), tab);
		}
		return map;
	}

}
